{"ts":1363420597402,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n\n/**\n * You can pass in a random number generator object if you like.\n * It is assumed to have a random() method.\n */\nvar SimplexNoise = function(r) {\n\tif (r == undefined) r = Math;\n  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], \n                                 [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], \n                                 [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; \n  this.p = [];\n  for (var i=0; i<256; i++) {\n\t  this.p[i] = Math.floor(r.random()*256);\n  }\n  // To remove the need for index wrapping, double the permutation table length \n  this.perm = []; \n  for(var i=0; i<512; i++) {\n\t\tthis.perm[i]=this.p[i & 255];\n\t} \n\n  // A lookup table to traverse the simplex around a given point in 4D. \n  // Details can be found where this table is used, in the 4D noise method. \n  this.simplex = [ \n    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0], \n    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0], \n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0], \n    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0], \n    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0], \n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0], \n    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0], \n    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]; \n};\n\nSimplexNoise.prototype.dot = function(g, x, y) { \n\treturn g[0]*x + g[1]*y;\n};\n\nSimplexNoise.prototype.noise = function(xin, yin) { \n  var n0, n1, n2; // Noise contributions from the three corners \n  // Skew the input space to determine which simplex cell we're in \n  var F2 = 0.5*(Math.sqrt(3.0)-1.0); \n  var s = (xin+yin)*F2; // Hairy factor for 2D \n  var i = Math.floor(xin+s); \n  var j = Math.floor(yin+s); \n  var G2 = (3.0-Math.sqrt(3.0))/6.0; \n  var t = (i+j)*G2; \n  var X0 = i-t; // Unskew the cell origin back to (x,y) space \n  var Y0 = j-t; \n  var x0 = xin-X0; // The x,y distances from the cell origin \n  var y0 = yin-Y0; \n  // For the 2D case, the simplex shape is an equilateral triangle. \n  // Determine which simplex we are in. \n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords \n  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1) \n  else {i1=0; j1=1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1) \n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and \n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where \n  // c = (3-sqrt(3))/6 \n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords \n  var y1 = y0 - j1 + G2; \n  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords \n  var y2 = y0 - 1.0 + 2.0 * G2; \n  // Work out the hashed gradient indices of the three simplex corners \n  var ii = i & 255; \n  var jj = j & 255; \n  var gi0 = this.perm[ii+this.perm[jj]] % 12; \n  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12; \n  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12; \n  // Calculate the contribution from the three corners \n  var t0 = 0.5 - x0*x0-y0*y0; \n  if(t0<0) n0 = 0.0; \n  else { \n    t0 *= t0; \n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient \n  } \n  var t1 = 0.5 - x1*x1-y1*y1; \n  if(t1<0) n1 = 0.0; \n  else { \n    t1 *= t1; \n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); \n  }\n  var t2 = 0.5 - x2*x2-y2*y2; \n  if(t2<0) n2 = 0.0; \n  else { \n    t2 *= t2; \n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); \n  } \n  // Add contributions from each corner to get the final noise value. \n  // The result is scaled to return values in the interval [-1,1]. \n  return 70.0 * (n0 + n1 + n2); \n};\n\n// 3D simplex noise \nSimplexNoise.prototype.noise3d = function(xin, yin, zin) { \n  var n0, n1, n2, n3; // Noise contributions from the four corners \n  // Skew the input space to determine which simplex cell we're in \n  var F3 = 1.0/3.0; \n  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D \n  var i = Math.floor(xin+s); \n  var j = Math.floor(yin+s); \n  var k = Math.floor(zin+s); \n  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too \n  var t = (i+j+k)*G3; \n  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space \n  var Y0 = j-t; \n  var Z0 = k-t; \n  var x0 = xin-X0; // The x,y,z distances from the cell origin \n  var y0 = yin-Y0; \n  var z0 = zin-Z0; \n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron. \n  // Determine which simplex we are in. \n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords \n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords \n  if(x0>=y0) { \n    if(y0>=z0) \n      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order \n      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order \n      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order \n    } \n  else { // x0<y0 \n    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order \n    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order \n    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order \n  } \n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), \n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and \n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where \n  // c = 1/6.\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords \n  var y1 = y0 - j1 + G3; \n  var z1 = z0 - k1 + G3; \n  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords \n  var y2 = y0 - j2 + 2.0*G3; \n  var z2 = z0 - k2 + 2.0*G3; \n  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords \n  var y3 = y0 - 1.0 + 3.0*G3; \n  var z3 = z0 - 1.0 + 3.0*G3; \n  // Work out the hashed gradient indices of the four simplex corners \n  var ii = i & 255; \n  var jj = j & 255; \n  var kk = k & 255; \n  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12; \n  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12; \n  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12; \n  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12; \n  // Calculate the contribution from the four corners \n  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0; \n  if(t0<0) n0 = 0.0; \n  else { \n    t0 *= t0; \n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0); \n  }\n  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1; \n  if(t1<0) n1 = 0.0; \n  else { \n    t1 *= t1; \n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1); \n  } \n  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2; \n  if(t2<0) n2 = 0.0; \n  else { \n    t2 *= t2; \n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2); \n  } \n  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3; \n  if(t3<0) n3 = 0.0; \n  else { \n    t3 *= t3; \n    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3); \n  } \n  // Add contributions from each corner to get the final noise value. \n  // The result is scaled to stay just inside [-1,1] \n  return 32.0*(n0 + n1 + n2 + n3); \n};"]],"start1":0,"start2":0,"length1":0,"length2":7362}]],"length":7362}
{"contributors":[],"silentsave":false,"ts":1363523367800,"patch":[[{"diffs":[[0,"entation"],[1,"\r"],[0,"\n// http"]],"start1":45,"start2":45,"length1":16,"length2":17},{"diffs":[[0,"oise.pdf"],[1,"\r"],[0,"\n// Read"]],"start1":113,"start2":113,"length1":16,"length2":17},{"diffs":[[0,"e works."],[1,"\r"],[0,"\n//"],[1,"\r"],[0,"\n// Sean"]],"start1":183,"start2":183,"length1":19,"length2":21},{"diffs":[[0,".com"],[-1,"\n"],[1,"\r\n//\r\n// Added 4D noise\r\n// Joshua Koo zz85nus@gmail.com \r"],[0,"\n/**"],[1,"\r"],[0,"\n * "]],"start1":230,"start2":230,"length1":13,"length2":71},{"diffs":[[0,"ou like."],[1,"\r"],[0,"\n * It i"]],"start1":354,"start2":354,"length1":16,"length2":17},{"diffs":[[0,"hod."],[1,"\r"],[0,"\n */"],[1,"\r"],[0,"\nvar"]],"start1":403,"start2":403,"length1":12,"length2":14},{"diffs":[[0,"ion(r) {"],[-1,"\n\t"],[1,"\r\n    "],[0,"if (r =="]],"start1":438,"start2":438,"length1":18,"length2":22},{"diffs":[[0," = Math;"],[-1,"\n"],[1,"\r\n  "],[0,"  this.g"]],"start1":473,"start2":473,"length1":17,"length2":20},{"diffs":[[0," = ["],[1,"\r\n      "],[0,"[1,"],[1," "],[0,"1,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[-1,"],[1," "],[0,"1,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[1,"],[1," "],[0,"-1,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[-1,"],[1," "],[0,"-1,"],[1," "],[0,"0],"],[-1," \n                                 [1,0,1],[-1,0,1],[1,0,-1],[-1,"],[1,"\r\n      [1, 0, 1],\r\n      [-1, 0, 1],\r\n      [1, 0, -1],\r\n      [-1, 0, -1],\r\n      [0, 1, 1],\r\n      [0, -1, 1],\r\n      [0, 1, -1],\r\n      [0, -1, -1]\r\n    ];\r\n\r\n    this.grad4 = [\r\n      [0, 1, 1, 1],\r\n      [0, 1, 1, -1],\r\n      [0, 1, -1, 1],\r\n      [0, 1, -1, -1],\r\n      ["],[0,"0,"],[1," "],[0,"-1"],[-1,"], \n                           "],[1,", 1, 1],\r\n      [0, -1, 1, -1],\r\n      [0, -1, -1, 1],\r\n      [0, -1, -1, -1],\r\n      [1, 0, 1, 1],\r\n"],[0,"      ["],[1,"1, "],[0,"0,"],[1," "],[0,"1,"],[1," -"],[0,"1],"],[-1,"["],[1,"\r\n      [1, "],[0,"0,"],[1," "],[0,"-1,"],[1," "],[0,"1],"],[-1,"[0,"],[1,"\r\n      [1, 0, -"],[0,"1,"],[1," "],[0,"-1],"],[-1,"[0,-1,-1]]; \n"],[1,"\r\n      [-1, 0, 1, 1],\r\n      [-1, 0, 1, -1],\r\n      [-1, 0, -1, 1],\r\n      [-1, 0, -1, -1],\r\n      [1, 1, 0, 1],\r\n      [1, 1, 0, -1],\r\n      [1, -1, 0, 1],\r\n      [1, -1, 0, -1],\r\n      [-1, 1, 0, 1],\r\n      [-1, 1, 0, -1],\r\n      [-1, -1, 0, 1],\r\n      [-1, -1, 0, -1],\r\n      [1, 1, 1, 0],\r\n      [1, 1, -1, 0],\r\n      [1, -1, 1, 0],\r\n      [1, -1, -1, 0],\r\n      [-1, 1, 1, 0],\r\n      [-1, 1, -1, 0],\r\n      [-1, -1, 1, 0],\r\n      [-1, -1, -1, 0]\r\n    ];\r\n\r\n  "],[0,"  th"]],"start1":497,"start2":497,"length1":189,"length2":998},{"diffs":[[0,".p = [];"],[-1,"\n"],[1,"\r\n  "],[0,"  for (v"]],"start1":1497,"start2":1497,"length1":17,"length2":20},{"diffs":[[0,"r (var i"],[-1,"="],[1," = "],[0,"0; i"],[-1,"<"],[1," < "],[0,"256; i++"]],"start1":1513,"start2":1513,"length1":22,"length2":26},{"diffs":[[0,"; i++) {"],[-1,"\n\t"],[1,"\r\n    "],[0,"  this.p"]],"start1":1534,"start2":1534,"length1":18,"length2":22},{"diffs":[[0,"om()"],[-1,"*"],[1," * "],[0,"256);"],[1,"\r\n    }\r"],[0,"\n  "],[-1,"}\n"],[0,"  //"]],"start1":1579,"start2":1579,"length1":19,"length2":27},{"diffs":[[0," length "],[-1,"\n"],[1,"\r\n  "],[0,"  this.p"]],"start1":1674,"start2":1674,"length1":17,"length2":20},{"diffs":[[0," [];"],[1,"\r\n "],[0," "],[-1,"\n"],[0,"  for"],[1," "],[0,"(var i"],[-1,"="],[1," = "],[0,"0; i"],[-1,"<"],[1," < "],[0,"512;"]],"start1":1699,"start2":1699,"length1":27,"length2":34},{"diffs":[[0,"+) {"],[-1,"\n\t\t"],[1,"\r\n      "],[0,"this"]],"start1":1736,"start2":1736,"length1":11,"length2":16},{"diffs":[[0,".perm[i]"],[-1,"="],[1," = "],[0,"this.p[i"]],"start1":1752,"start2":1752,"length1":17,"length2":19},{"diffs":[[0,"55];"],[-1,"\n\t} \n\n"],[1,"\r\n    }\r\n\r\n  "],[0,"  //"]],"start1":1775,"start2":1775,"length1":14,"length2":21},{"diffs":[[0," in 4D. "],[-1,"\n"],[1,"\r\n  "],[0,"  // Det"]],"start1":1856,"start2":1856,"length1":17,"length2":20},{"diffs":[[0,"method. "],[-1,"\n"],[1,"\r\n  "],[0,"  this.s"]],"start1":1936,"start2":1936,"length1":17,"length2":20},{"diffs":[[0," = ["],[1,"\r\n "],[0," "],[-1,"\n"],[0,"    [0,"],[1," "],[0,"1,"],[1," "],[0,"2,"],[1," "],[0,"3],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"1,"],[1," "],[0,"3,"],[1," "],[0,"2],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"2,"],[1," "],[0,"3,"],[1," "],[0,"1],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[1,"],[1," "],[0,"2,"],[1," "],[0,"3,"],[1," "],[0,"0],"],[1,"\r\n "],[0," "],[-1,"\n"],[0,"    [0,"],[1," "],[0,"2,"],[1," "],[0,"1,"],[1," "],[0,"3],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"3,"],[1," "],[0,"1,"],[1," "],[0,"2],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"3,"],[1," "],[0,"2,"],[1," "],[0,"1],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[1,"],[1," "],[0,"3,"],[1," "],[0,"2,"],[1," "],[0,"0],"],[1,"\r\n"],[0," "],[-1,"\n"],[0,"    "],[1," "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n "],[0," "],[-1,"\n"],[0,"    [1,"],[1," "],[0,"2,"],[1," "],[0,"0,"],[1," "],[0,"3],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[1,"],[1," "],[0,"3,"],[1," "],[0,"0,"],[1," "],[0,"2],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[2,"],[1," "],[0,"3,"],[1," "],[0,"0,"],[1," "],[0,"1],"],[1,"\r\n      "],[0,"[2,"],[1," "],[0,"3,"],[1," "],[0,"1,"],[1," "],[0,"0],"],[1,"\r\n "],[0," "],[-1,"\n"],[0,"    [1,"],[1," "],[0,"0,"],[1," "],[0,"2,"],[1," "],[0,"3],"],[1,"\r\n      "],[0,"[1,"],[1," "],[0,"0,"],[1," "],[0,"3,"],[1," "],[0,"2],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[2,"],[1," "],[0,"0,"],[1," "],[0,"3,"],[1," "],[0,"1],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[2,"],[1," "],[0,"1,"],[1," "],[0,"3,"],[1," "],[0,"0],"],[1,"\r\n "],[0," "],[-1,"\n"],[0,"    [0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n"],[0," "],[-1,"\n"],[0,"    "],[1," "],[0,"[2,"],[1," "],[0,"0,"],[1," "],[0,"1,"],[1," "],[0,"3],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[3,"],[1," "],[0,"0,"],[1," "],[0,"1,"],[1," "],[0,"2],"],[1,"\r\n      "],[0,"[3,"],[1," "],[0,"0,"],[1," "],[0,"2,"],[1," "],[0,"1],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[3,"],[1," "],[0,"1,"],[1," "],[0,"2,"],[1," "],[0,"0],"],[1,"\r\n "],[0," "],[-1,"\n"],[0,"    [2,"],[1," "],[0,"1,"],[1," "],[0,"0,"],[1," "],[0,"3],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[3,"],[1," "],[0,"1,"],[1," "],[0,"0,"],[1," "],[0,"2],"],[1,"\r\n      "],[0,"[0,"],[1," "],[0,"0,"],[1," "],[0,"0,"],[1," "],[0,"0],"],[1,"\r\n      "],[0,"[3,"],[1," "],[0,"2,"],[1," "],[0,"0,"],[1," "],[0,"1],"],[1,"\r\n      "],[0,"[3,"],[1," "],[0,"2,"],[1," "],[0,"1,"],[1," "],[0,"0]"],[-1,"]; \n};\n"],[1,"\r\n    ];\r\n  };\r\n\r\nSimplexNoise.prototype.dot = function(g, x, y) {\r\n  return g[0] * x + g[1] * y;\r\n};\r\n\r"],[0,"\nSim"]],"start1":1962,"start2":1962,"length1":702,"length2":1455},{"diffs":[[0,"se.prototype.dot"],[1,"3"],[0," = function(g, x"]],"start1":3424,"start2":3424,"length1":32,"length2":33},{"diffs":[[0,"x, y"],[-1,") { \n\t"],[1,", z) {\r\n  return g[0] * x + g[1] * y + g[2] * z;\r\n}\r\n\r\nSimplexNoise.prototype.dot4 = function(g, x, y, z, w) {\r\n  "],[0,"retu"]],"start1":3456,"start2":3456,"length1":14,"length2":122},{"diffs":[[0,"g[0]"],[-1,"*"],[1," * "],[0,"x + g[1]"],[-1,"*y;\n};\n"],[1," * y + g[2] * z + g[3] * w;\r\n};\r\n\r"],[0,"\nSim"]],"start1":3581,"start2":3581,"length1":24,"length2":53},{"diffs":[[0,"(xin, yin) {"],[-1," "],[1,"\r"],[0,"\n  var n0, n"]],"start1":3670,"start2":3670,"length1":25,"length2":25},{"diffs":[[0,"e three corners "],[1,"\r"],[0,"\n  // Skew the i"]],"start1":3732,"start2":3732,"length1":32,"length2":33},{"diffs":[[0,"x cell we're in "],[1,"\r"],[0,"\n  var F2 = 0.5*"]],"start1":3801,"start2":3801,"length1":32,"length2":33},{"diffs":[[0,"F2 = 0.5"],[-1,"*"],[1," * "],[0,"(Math.sq"]],"start1":3825,"start2":3825,"length1":17,"length2":19},{"diffs":[[0,"3.0)"],[-1,"-"],[1," - "],[0,"1.0);"],[-1," "],[1,"\r"],[0,"\n  v"]],"start1":3847,"start2":3847,"length1":15,"length2":17},{"diffs":[[0,"(xin"],[-1,"+"],[1," + "],[0,"yin)"],[-1,"*"],[1," * "],[0,"F2; "]],"start1":3871,"start2":3871,"length1":14,"length2":18},{"diffs":[[0," for 2D "],[1,"\r"],[0,"\n  var i"]],"start1":3904,"start2":3904,"length1":16,"length2":17},{"diffs":[[0,"= Math.floor(xin"],[-1,"+s); "],[1," + s);\r"],[0,"\n  var j = Math."]],"start1":3922,"start2":3922,"length1":37,"length2":39},{"diffs":[[0,"th.floor(yin"],[-1,"+s); "],[1," + s);\r"],[0,"\n  var G2 = "]],"start1":3958,"start2":3958,"length1":29,"length2":31},{"diffs":[[0,"2 = (3.0"],[-1,"-"],[1," - "],[0,"Math.sqr"]],"start1":3985,"start2":3985,"length1":17,"length2":19},{"diffs":[[0,"rt(3.0))"],[-1,"/"],[1," / "],[0,"6.0;"],[-1," "],[1,"\r"],[0,"\n  var t"]],"start1":4003,"start2":4003,"length1":22,"length2":24},{"diffs":[[0,"= (i"],[-1,"+j)*G2; "],[1," + j) * G2;\r"],[0,"\n  v"]],"start1":4028,"start2":4028,"length1":16,"length2":20},{"diffs":[[0,"2;\r\n  var X0 = i"],[-1,"-"],[1," - "],[0,"t; // Unskew the"]],"start1":4041,"start2":4041,"length1":33,"length2":35},{"diffs":[[0," to (x,y) space "],[1,"\r"],[0,"\n  var Y0 = j-t;"]],"start1":4093,"start2":4093,"length1":32,"length2":33},{"diffs":[[0,"  var Y0 = j"],[-1,"-t; "],[1," - t;\r"],[0,"\n  var x0 = "]],"start1":4111,"start2":4111,"length1":28,"length2":30},{"diffs":[[0,"\r\n  var x0 = xin"],[-1,"-"],[1," - "],[0,"X0; // The x,y d"]],"start1":4128,"start2":4128,"length1":33,"length2":35},{"diffs":[[0,"the cell origin "],[1,"\r"],[0,"\n  var y0 = yin-"]],"start1":4177,"start2":4177,"length1":32,"length2":33},{"diffs":[[0,"y0 = yin"],[-1,"-Y0; "],[1," - Y0;\r"],[0,"\n  // Fo"]],"start1":4201,"start2":4201,"length1":21,"length2":23},{"diffs":[[0,"iangle. "],[1,"\r"],[0,"\n  // De"]],"start1":4277,"start2":4277,"length1":16,"length2":17},{"diffs":[[0,"plex we are in. "],[1,"\r"],[0,"\n  var i1, j1; /"]],"start1":4311,"start2":4311,"length1":32,"length2":33},{"diffs":[[0,"rds "],[1,"\r"],[0,"\n  if"],[1," "],[0,"(x0"],[-1,">"],[1," > "],[0,"y0) {"],[-1,"i1=1; j1=0;"],[1,"\r\n    i1 = 1;\r\n    j1 = 0;\r\n  "],[0,"} //"]],"start1":4404,"start2":4404,"length1":33,"length2":56},{"diffs":[[0,"->(1,1) "],[1,"\r"],[0,"\n  else "]],"start1":4499,"start2":4499,"length1":16,"length2":17},{"diffs":[[0,"se {"],[-1,"i1=0; j1=1;}   "],[1,"\r\n    i1 = 0;\r\n    j1 = 1;\r\n"],[0,"  "],[1,"}"],[0," // "]],"start1":4513,"start2":4513,"length1":25,"length2":39},{"diffs":[[0,"->(1,1) "],[1,"\r"],[0,"\n  // A "]],"start1":4590,"start2":4590,"length1":16,"length2":17},{"diffs":[[0," (x,y), and "],[1,"\r"],[0,"\n  // a step"]],"start1":4657,"start2":4657,"length1":24,"length2":25},{"diffs":[[0,"in (x,y), where "],[1,"\r"],[0,"\n  // c = (3-sqr"]],"start1":4726,"start2":4726,"length1":32,"length2":33},{"diffs":[[0,"t(3))/6 "],[1,"\r"],[0,"\n  var x"]],"start1":4759,"start2":4759,"length1":16,"length2":17},{"diffs":[[0,"unskewed coords "],[1,"\r"],[0,"\n  var y1 = y0 -"]],"start1":4832,"start2":4832,"length1":32,"length2":33},{"diffs":[[0,"j1 + G2;"],[-1," "],[1,"\r"],[0,"\n  var x"]],"start1":4866,"start2":4866,"length1":17,"length2":17},{"diffs":[[0,"unskewed coords "],[1,"\r"],[0,"\n  var y2 = y0 -"]],"start1":4944,"start2":4944,"length1":32,"length2":33},{"diffs":[[0,".0 * G2;"],[-1," "],[1,"\r"],[0,"\n  // Wo"]],"start1":4985,"start2":4985,"length1":17,"length2":17},{"diffs":[[0,"simplex corners "],[1,"\r"],[0,"\n  var ii = i & "]],"start1":5050,"start2":5050,"length1":32,"length2":33},{"diffs":[[0,"ar ii = i & 255;"],[-1," "],[1,"\r"],[0,"\n  var jj = j & "]],"start1":5071,"start2":5071,"length1":33,"length2":33},{"diffs":[[0,"j = j & 255;"],[-1," "],[1,"\r"],[0,"\n  var gi0 ="]],"start1":5096,"start2":5096,"length1":25,"length2":25},{"diffs":[[0,"0 = this.perm[ii"],[-1,"+"],[1," + "],[0,"this.perm[jj]] %"]],"start1":5118,"start2":5118,"length1":33,"length2":35},{"diffs":[[0,".perm[jj]] % 12;"],[-1," "],[1,"\r"],[0,"\n  var gi1 = thi"]],"start1":5141,"start2":5141,"length1":33,"length2":33},{"diffs":[[0,"1 = this.perm[ii"],[-1,"+i1+"],[1," + i1 + "],[0,"this.perm[jj+j1]"]],"start1":5167,"start2":5167,"length1":36,"length2":40},{"diffs":[[0,".perm[jj"],[-1,"+"],[1," + "],[0,"j1]] % 1"]],"start1":5195,"start2":5195,"length1":17,"length2":19},{"diffs":[[0,"[jj + j1]] % 12;"],[-1," "],[1,"\r"],[0,"\n  var gi2 = thi"]],"start1":5200,"start2":5200,"length1":33,"length2":33},{"diffs":[[0,"2 = this.perm[ii"],[-1,"+1+"],[1," + 1 + "],[0,"this.perm[jj+1]]"]],"start1":5226,"start2":5226,"length1":35,"length2":39},{"diffs":[[0,".perm[jj"],[-1,"+"],[1," + "],[0,"1]] % 12"]],"start1":5253,"start2":5253,"length1":17,"length2":19},{"diffs":[[0,"m[jj + 1]] % 12;"],[-1," "],[1,"\r"],[0,"\n  // Calculate "]],"start1":5257,"start2":5257,"length1":33,"length2":33},{"diffs":[[0,"e three corners "],[1,"\r"],[0,"\n  var t0 = 0.5 "]],"start1":5314,"start2":5314,"length1":32,"length2":33},{"diffs":[[0,"- x0"],[-1,"*x0-y0*y0; "],[1," * x0 - y0 * y0;\r"],[0,"\n  if"],[1," "],[0,"(t0"],[-1,"<"],[1," < "],[0,"0) n"]],"start1":5347,"start2":5347,"length1":28,"length2":37},{"diffs":[[0,"0 < 0) n0 = 0.0;"],[-1," "],[1,"\r"],[0,"\n  else { \n    t"]],"start1":5376,"start2":5376,"length1":33,"length2":33},{"diffs":[[0,"= 0.0;\r\n  else {"],[-1," "],[1,"\r"],[0,"\n    t0 *= t0; \n"]],"start1":5386,"start2":5386,"length1":33,"length2":33},{"diffs":[[0," t0;"],[-1," \n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient \n  } \n  var t1 = 0.5 - x1*x1-y1*y1; \n  if(t1<0) n1 = 0.0; \n  else { \n    t1 *= t1; \n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); \n  }\n  var t2 = 0.5 - x2*x2-y2*y2; \n  if(t2<0) n2 = 0.0; \n  else { \n    t2 *= t2; \n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); \n  } \n  // Add contributions from each corner to get the final noise value. \n  // The result is scaled to return values in the interval [-1,1]. \n  return 70.0 * (n0 + n1 + n2); \n};\n\n// 3D simplex noise \nSimplexNoise.prototype.noise3d = function(xin, yin, zin) { \n  var n0, n1, n2, n3; // Noise contributions from the four corners \n  // Skew the input space to determine which simplex cell we're in \n  var F3 = 1.0/3.0; \n  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D \n  var i = Math.floor(xin+s); \n  var j = Math.floor(yin+s); \n  var k = Math.floor(zin+s); \n  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too \n  var t = (i+j+k)*G3; \n  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space \n  var Y0 = j-t; \n  var Z0 = k-t; \n  var x0 = xin-X0; // The x,y,z distances from the cell origin \n  var y0 = yin-Y0; \n  var z0 = zin-Z0; \n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron. \n  // Determine which simplex we are in. \n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords \n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords \n  if(x0>=y0) { \n    if(y0>=z0) \n      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order \n      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order \n      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order \n    } \n  else { // x0<y0 \n    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order \n    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order \n    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order \n  } \n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), \n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and \n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where \n  // c = 1/6.\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords \n  var y1 = y0 - j1 + G3; \n  var z1 = z0 - k1 + G3; \n  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords \n  var y2 = y0 - j2 + 2.0*G3; \n  var z2 = z0 - k2 + 2.0*G3; \n  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords \n  var y3 = y0 - 1.0 + 3.0*G3; \n  var z3 = z0 - 1.0 + 3.0*G3; \n  // Work out the hashed gradient indices of the four simplex corners \n  var ii = i & 255; \n  var jj = j & 255; \n  var kk = k & 255; \n  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12; \n  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12; \n  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12; \n  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12; \n  // Calculate the contribution from the four corners \n  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0; \n  if(t0<0) n0 = 0.0; \n  else { \n    t0 *= t0; \n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0); \n  }\n  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1; \n  if(t1<0) n1 = 0.0; \n  else { \n    t1 *= t1; \n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1); \n  } \n  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2; \n  if(t2<0) n2 = 0.0; \n  else { \n    t2 *= t2; \n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2); \n  } \n  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3; \n  if(t3<0) n3 = 0.0; \n  else { \n    t3 *= t3; \n    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3); \n  } \n  // Add contributions from each corner to get the final noise value. \n  // The result is scaled to stay just inside [-1,1] \n  return 32.0*(n0 + n1 + n2 + n3); "],[1,"\r\n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient \r\n  }\r\n  var t1 = 0.5 - x1 * x1 - y1 * y1;\r\n  if (t1 < 0) n1 = 0.0;\r\n  else {\r\n    t1 *= t1;\r\n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\r\n  }\r\n  var t2 = 0.5 - x2 * x2 - y2 * y2;\r\n  if (t2 < 0) n2 = 0.0;\r\n  else {\r\n    t2 *= t2;\r\n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\r\n  }\r\n  // Add contributions from each corner to get the final noise value. \r\n  // The result is scaled to return values in the interval [-1,1]. \r\n  return 70.0 * (n0 + n1 + n2);\r\n};\r\n\r\n// 3D simplex noise \r\nSimplexNoise.prototype.noise3d = function(xin, yin, zin) {\r\n  var n0, n1, n2, n3; // Noise contributions from the four corners \r\n  // Skew the input space to determine which simplex cell we're in \r\n  var F3 = 1.0 / 3.0;\r\n  var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D \r\n  var i = Math.floor(xin + s);\r\n  var j = Math.floor(yin + s);\r\n  var k = Math.floor(zin + s);\r\n  var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too \r\n  var t = (i + j + k) * G3;\r\n  var X0 = i - t; // Unskew the cell origin back to (x,y,z) space \r\n  var Y0 = j - t;\r\n  var Z0 = k - t;\r\n  var x0 = xin - X0; // The x,y,z distances from the cell origin \r\n  var y0 = yin - Y0;\r\n  var z0 = zin - Z0;\r\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron. \r\n  // Determine which simplex we are in. \r\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords \r\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords \r\n  if (x0 >= y0) {\r\n    if (y0 >= z0) {\r\n      i1 = 1;\r\n      j1 = 0;\r\n      k1 = 0;\r\n      i2 = 1;\r\n      j2 = 1;\r\n      k2 = 0;\r\n    } // X Y Z order \r\n    else if (x0 >= z0) {\r\n      i1 = 1;\r\n      j1 = 0;\r\n      k1 = 0;\r\n      i2 = 1;\r\n      j2 = 0;\r\n      k2 = 1;\r\n    } // X Z Y order \r\n    else {\r\n      i1 = 0;\r\n      j1 = 0;\r\n      k1 = 1;\r\n      i2 = 1;\r\n      j2 = 0;\r\n      k2 = 1;\r\n    } // Z X Y order \r\n  } else { // x0<y0 \r\n    if (y0 < z0) {\r\n      i1 = 0;\r\n      j1 = 0;\r\n      k1 = 1;\r\n      i2 = 0;\r\n      j2 = 1;\r\n      k2 = 1;\r\n    } // Z Y X order \r\n    else if (x0 < z0) {\r\n      i1 = 0;\r\n      j1 = 1;\r\n      k1 = 0;\r\n      i2 = 0;\r\n      j2 = 1;\r\n      k2 = 1;\r\n    } // Y Z X order \r\n    else {\r\n      i1 = 0;\r\n      j1 = 1;\r\n      k1 = 0;\r\n      i2 = 1;\r\n      j2 = 1;\r\n      k2 = 0;\r\n    } // Y X Z order \r\n  }\r\n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), \r\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and \r\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where \r\n  // c = 1/6.\r\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords \r\n  var y1 = y0 - j1 + G3;\r\n  var z1 = z0 - k1 + G3;\r\n  var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords \r\n  var y2 = y0 - j2 + 2.0 * G3;\r\n  var z2 = z0 - k2 + 2.0 * G3;\r\n  var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords \r\n  var y3 = y0 - 1.0 + 3.0 * G3;\r\n  var z3 = z0 - 1.0 + 3.0 * G3;\r\n  // Work out the hashed gradient indices of the four simplex corners \r\n  var ii = i & 255;\r\n  var jj = j & 255;\r\n  var kk = k & 255;\r\n  var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;\r\n  var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;\r\n  var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;\r\n  var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;\r\n  // Calculate the contribution from the four corners \r\n  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\r\n  if (t0 < 0) n0 = 0.0;\r\n  else {\r\n    t0 *= t0;\r\n    n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\r\n  }\r\n  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\r\n  if (t1 < 0) n1 = 0.0;\r\n  else {\r\n    t1 *= t1;\r\n    n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\r\n  }\r\n  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\r\n  if (t2 < 0) n2 = 0.0;\r\n  else {\r\n    t2 *= t2;\r\n    n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\r\n  }\r\n  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\r\n  if (t3 < 0) n3 = 0.0;\r\n  else {\r\n    t3 *= t3;\r\n    n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\r\n  }\r\n  // Add contributions from each corner to get the final noise value. \r\n  // The result is scaled to stay just inside [-1,1] \r\n  return 32.0 * (n0 + n1 + n2 + n3);\r\n};\r\n\r\n// 4D simplex noise\r\nSimplexNoise.prototype.noise4d = function(x, y, z, w) {\r\n  // For faster and easier lookups\r\n  var grad4 = this.grad4;\r\n  var simplex = this.simplex;\r\n  var perm = this.perm;\r\n\r\n  // The skewing and unskewing factors are hairy again for the 4D case\r\n  var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\r\n  var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\r\n  var n0, n1, n2, n3, n4; // Noise contributions from the five corners\r\n  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\r\n  var s = (x + y + z + w) * F4; // Factor for 4D skewing\r\n  var i = Math.floor(x + s);\r\n  var j = Math.floor(y + s);\r\n  var k = Math.floor(z + s);\r\n  var l = Math.floor(w + s);\r\n  var t = (i + j + k + l) * G4; // Factor for 4D unskewing\r\n  var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\r\n  var Y0 = j - t;\r\n  var Z0 = k - t;\r\n  var W0 = l - t;\r\n  var x0 = x - X0; // The x,y,z,w distances from the cell origin\r\n  var y0 = y - Y0;\r\n  var z0 = z - Z0;\r\n  var w0 = w - W0;\r\n\r\n  // For the 4D case, the simplex is a 4D shape I won't even try to describe.\r\n  // To find out which of the 24 possible simplices we're in, we need to\r\n  // determine the magnitude ordering of x0, y0, z0 and w0.\r\n  // The method below is a good way of finding the ordering of x,y,z,w and\r\n  // then find the correct traversal order for the simplex weâ€™re in.\r\n  // First, six pair-wise comparisons are performed between each possible pair\r\n  // of the four coordinates, and the results are used to add up binary bits\r\n  // for an integer index.\r\n  var c1 = (x0 > y0) ? 32 : 0;\r\n  var c2 = (x0 > z0) ? 16 : 0;\r\n  var c3 = (y0 > z0) ? 8 : 0;\r\n  var c4 = (x0 > w0) ? 4 : 0;\r\n  var c5 = (y0 > w0) ? 2 : 0;\r\n  var c6 = (z0 > w0) ? 1 : 0;\r\n  var c = c1 + c2 + c3 + c4 + c5 + c6;\r\n  var i1, j1, k1, l1; // The integer offsets for the second simplex corner\r\n  var i2, j2, k2, l2; // The integer offsets for the third simplex corner\r\n  var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\r\n  // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\r\n  // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\r\n  // impossible. Only the 24 indices which have non-zero entries make any sense.\r\n  // We use a thresholding to set the coordinates in turn from the largest magnitude.\r\n  // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\r\n  i1 = simplex[c][0] >= 3 ? 1 : 0;\r\n  j1 = simplex[c][1] >= 3 ? 1 : 0;\r\n  k1 = simplex[c][2] >= 3 ? 1 : 0;\r\n  l1 = simplex[c][3] >= 3 ? 1 : 0;\r\n  // The number 2 in the \"simplex\" array is at the second largest coordinate.\r\n  i2 = simplex[c][0] >= 2 ? 1 : 0;\r\n  j2 = simplex[c][1] >= 2 ? 1 : 0;\r\n  k2 = simplex[c][2] >= 2 ? 1 : 0;\r\n  l2 = simplex[c][3] >= 2 ? 1 : 0;\r\n  // The number 1 in the \"simplex\" array is at the second smallest coordinate.\r\n  i3 = simplex[c][0] >= 1 ? 1 : 0;\r\n  j3 = simplex[c][1] >= 1 ? 1 : 0;\r\n  k3 = simplex[c][2] >= 1 ? 1 : 0;\r\n  l3 = simplex[c][3] >= 1 ? 1 : 0;\r\n  // The fifth corner has all coordinate offsets = 1, so no need to look that up.\r\n  var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\r\n  var y1 = y0 - j1 + G4;\r\n  var z1 = z0 - k1 + G4;\r\n  var w1 = w0 - l1 + G4;\r\n  var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\r\n  var y2 = y0 - j2 + 2.0 * G4;\r\n  var z2 = z0 - k2 + 2.0 * G4;\r\n  var w2 = w0 - l2 + 2.0 * G4;\r\n  var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\r\n  var y3 = y0 - j3 + 3.0 * G4;\r\n  var z3 = z0 - k3 + 3.0 * G4;\r\n  var w3 = w0 - l3 + 3.0 * G4;\r\n  var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\r\n  var y4 = y0 - 1.0 + 4.0 * G4;\r\n  var z4 = z0 - 1.0 + 4.0 * G4;\r\n  var w4 = w0 - 1.0 + 4.0 * G4;\r\n  // Work out the hashed gradient indices of the five simplex corners\r\n  var ii = i & 255;\r\n  var jj = j & 255;\r\n  var kk = k & 255;\r\n  var ll = l & 255;\r\n  var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\r\n  var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\r\n  var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\r\n  var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\r\n  var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;\r\n  // Calculate the contribution from the five corners\r\n  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\r\n  if (t0 < 0) n0 = 0.0;\r\n  else {\r\n    t0 *= t0;\r\n    n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\r\n  }\r\n  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\r\n  if (t1 < 0) n1 = 0.0;\r\n  else {\r\n    t1 *= t1;\r\n    n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\r\n  }\r\n  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\r\n  if (t2 < 0) n2 = 0.0;\r\n  else {\r\n    t2 *= t2;\r\n    n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\r\n  }\r\n  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\r\n  if (t3 < 0) n3 = 0.0;\r\n  else {\r\n    t3 *= t3;\r\n    n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\r\n  }\r\n  var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\r\n  if (t4 < 0) n4 = 0.0;\r\n  else {\r\n    t4 *= t4;\r\n    n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\r\n  }\r\n  // Sum up and scale the result to cover the range [-1,1]\r\n  return 27.0 * (n0 + n1 + n2 + n3 + n4);\r"],[0,"\n};"]],"start1":5413,"start2":5413,"length1":3874,"length2":9734}]],"length":15147,"saved":false}
